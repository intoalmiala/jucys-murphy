import Mathlib
import JucysMurphy.Utils

open Equiv

noncomputable section

def jucysMurphyElem (k n : ℕ) [NeZero n] : A n :=
  ∑ i : Fin n with ↑i ∈ Finset.range (k - 1), A_of (swap i ↑(k - 1))

abbrev X := jucysMurphyElem

theorem X_def {k n : ℕ} [NeZero n] : X k n = ∑ i :
    Fin n with ↑i ∈ Finset.range (k - 1), A_of (swap i ↑(k - 1)) := rfl

theorem jucysMurphyElem_comm_lt_perm {n m : ℕ} [NeZero n] [NeZero m] (σ : S n) (h_lt : n < m) :
    Commute (X m m) (MonoidAlgebra.castLTHom h_lt (A_of σ)) := by
  rw [X_def, commute_iff_eq]
  -- Distributivity
  rw [Finset.mul_sum]
  conv =>
    enter [2, 2, i]
    rw [MonoidAlgebra.castLTHom_apply]
    rw [←MonoidHom.map_mul A_of (Perm.castLTHom h_lt σ) (swap i ↑(m - 1))]
    rw [castLTHom_swap_eq_swap_castLTHom]
    rw [MonoidHom.map_mul A_of (swap (Perm.castLTHom h_lt σ i) ↑(m - 1))]
  conv =>
    rhs
    rw [←Finset.sum_mul]
  -- Use the reordering lemma
  rw [Perm.sum_swap_castLTHom_eq_sum_swap]
  -- lift_perm same as lift_monAlg
  rw [MonoidAlgebra.castLTHom_apply]

lemma MonoidAlgebra.castLEHom_jucysMurphyElem_eq {n m k : ℕ} [NeZero n] [NeZero m] [NeZero k]
    (n_le_m : n ≤ m) (k_le_n : k ≤ n) : MonoidAlgebra.castLEHom n_le_m (X k n) = X k m := by
  unfold X jucysMurphyElem
  rw [map_sum] -- Linearity
  -- This is again needed since we want to sum over a Fintype very often
  rw [sum_fin_eq_sum_nat (Nat.le_trans (Nat.le_trans (by simp) k_le_n) n_le_m)]
  rw [sum_fin_eq_sum_nat (Nat.le_trans (by simp) k_le_n)]
  apply Finset.sum_congr
  · rfl
  · intro i hi
    rw [MonoidAlgebra.castLEHom_apply]
    congr
    simp at hi
    apply Perm.castLEHom_swap_eq
    · -- Can't get linarith to do this nicely so a bit verbose
      exact Nat.lt_of_lt_of_le (Nat.lt_of_lt_pred hi) k_le_n
    · refine lt_of_lt_of_le ?_ k_le_n
      simp
      exact Nat.pos_of_neZero k

lemma MonoidAlgebra.castLTHom_jucysMurphyElem_eq {n m k : ℕ} [NeZero n] [NeZero m] [NeZero k]
    (n_lt_m : n < m) (k_le_n : k ≤ n) : MonoidAlgebra.castLTHom n_lt_m (X k n) = X k m :=
  MonoidAlgebra.castLEHom_jucysMurphyElem_eq (le_of_lt n_lt_m) k_le_n

-- This is one of the two main results
theorem jucysMurphyElem_comm_lt_monoidAlgebra {n m : ℕ} [NeZero m] [NeZero n]
    (a : A n) (h_lt : n < m) : Commute (X m m) (MonoidAlgebra.castLTHom h_lt a) := by
  -- Decompose into sum of singles
  rw [← a.sum_single]
  unfold Finsupp.sum
  -- Move lift_monAlg inside sum
  rw [map_sum $ MonoidAlgebra.castLTHom h_lt]
  -- Move a x out of lift_monAlg
  conv in fun x ↦ _ =>
    intro x
    rw [← mul_one (a x)]
    rw [← MonoidAlgebra.smul_single' (a x) x 1]
    rw [map_smul]
  rw [commute_iff_eq]
  -- Move multiplication by jmElem inside the sums
  rw [Finset.mul_sum, Finset.sum_mul]
  conv in fun i ↦ _ =>
    intro i
    rw [mul_smul_comm]
    tactic => have comm_perm := jucysMurphyElem_comm_lt_perm i h_lt
    tactic => simp at comm_perm
    rw [comm_perm]
    rw [← smul_mul_assoc]

lemma jucysMurphyElem_comm_of_le_comm {n m k l : ℕ} [NeZero n] [NeZero m] [NeZero k] [NeZero l]
    (n_le_m : n ≤ m) (k_le_n : k ≤ n) (l_le_n : l ≤ n)  (h_comm : Commute (X k n) (X l n)) :
    Commute (X k m) (X l m) := by
  repeat rw [← MonoidAlgebra.castLEHom_jucysMurphyElem_eq n_le_m]
  rw [commute_iff_eq] at *
  repeat rw [← map_mul $ MonoidAlgebra.castLEHom n_le_m]
  rw [h_comm]
  all_goals assumption

lemma jucysMurphyElem_comm' {n k l : ℕ} [NeZero n] [NeZero k] [NeZero l]
    (hl_le_n : l ≤ n) (hk_lt_l : k < l) : Commute (X k n) (X l n) := by
  have l_pred_le_n : l - 1 ≤ n := le_trans (by simp) hl_le_n
  have l_pred_nz : NeZero (l - 1) := by
    apply NeZero.of_pos
    simp
    have k_nz : k > 0 := Nat.pos_of_neZero k
    exact Nat.lt_of_le_of_lt k_nz hk_lt_l
  have h_lt : l - 1 < l := Nat.sub_one_lt_of_lt hk_lt_l
  suffices h : Commute (MonoidAlgebra.castLTHom h_lt $ X k (l - 1)) (X l l) by
    rw [MonoidAlgebra.castLTHom_jucysMurphyElem_eq h_lt] at h
    · exact jucysMurphyElem_comm_of_le_comm hl_le_n (by linarith) (by linarith) h
    · exact Nat.le_pred_of_lt hk_lt_l
  exact (jucysMurphyElem_comm_lt_monoidAlgebra (X k (l - 1)) h_lt).symm

theorem jucysMurphyElem_comm {n k l : ℕ} [NeZero n] [NeZero k] [NeZero l]
    (h_le : l ≤ n ∧ k ≤ n) : Commute (X k n) (X l n) := by
  by_cases h_eq : k = l
  · rw [h_eq]
  suffices h : k < l → Commute (X k n) (X l n) by
    by_cases h_lt : k < l
    · exact h h_lt
    · simp at h_lt
      have h_lt : l < k := lt_of_le_of_ne' h_lt h_eq
      exact (jucysMurphyElem_comm' h_le.right h_lt).symm
  intro h_lt
  exact jucysMurphyElem_comm' h_le.left h_lt

-- All Jucys-Murphy elements belonging to ℂ[Sₙ]
def jucysMurphyElem_set (n : ℕ) [NeZero n] : Set (A n) :=
  {x | ∃ (m : ℕ), m ∈ Set.Icc 1 n ∧ x = X m n}

-- In Lean, the structure generated by some set is called the `adjoin`
def jucysMurphyElem_subalgebra (n : ℕ) [NeZero n] : Subalgebra ℂ (A n) :=
  Algebra.adjoin ℂ (jucysMurphyElem_set n)

-- To be precise, we call an algebra commutative if the underlying semiring of this
-- (the structure we get when forgetting scalar multiplication) is commutative
-- This is the second of the two main results.
instance jucysMurphyElem_adjoin_comm (n : ℕ) [NeZero n] :
    CommSemiring (jucysMurphyElem_subalgebra n) := by
  -- MAIN LEMMA: Underlying semiring of a subalgebra commutative if generators commute
  apply Algebra.adjoinCommSemiringOfComm
  intro a ha b hb
  unfold jucysMurphyElem_set at ha hb
  simp at ha hb
  obtain ⟨k, hk_ge_and_le, ha_eq⟩ := ha
  obtain ⟨hk_ge, hk_le⟩ := hk_ge_and_le
  obtain ⟨l, hl_ge_and_le, hb_eq⟩ := hb
  obtain ⟨hl_ge, hl_le⟩ := hl_ge_and_le
  rw [ha_eq, hb_eq]
  have : NeZero k := ⟨by linarith⟩
  have : NeZero l := ⟨by linarith⟩
  exact jucysMurphyElem_comm (by constructor; exact hl_le; exact hk_le)
